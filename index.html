<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Symbiotic 3D Collector â€” Play</title>

<!-- three.js r152 (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/PointerLockControls.js"></script>

<style>
  :root {
    --bg: #071916;
    --accent: #40ffb7;
    --muted: rgba(255,255,255,0.75);
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#041812,#062f24);font-family:Inter,system-ui,Arial;color:#e9fff3}
  #container{width:100%;height:100%;display:flex;align-items:stretch;justify-content:center}
  #gameWrap{width:100%;max-width:1200px;height:100vh;position:relative;overflow:hidden}
  canvas{display:block}

  /* HUD */
  .hud{
    position:absolute;left:16px;top:16px;z-index:10;display:flex;gap:12px;align-items:center;
    backdrop-filter: blur(4px);
  }
  .logo {
    width:56px;height:56px;border-radius:10px;background:#fff;overflow:hidden;display:flex;align-items:center;justify-content:center;
    box-shadow:0 8px 30px rgba(0,0,0,0.5);
  }
  .logo img{width:100%;height:100%;object-fit:contain}
  .stats{padding:10px 14px;border-radius:10px;background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.04)}
  .stats div{font-weight:700}
  .stats .muted{font-weight:400;color:var(--muted);font-size:0.9rem}

  /* right controls */
  .controls-right{position:absolute;right:16px;top:16px;z-index:10;display:flex;gap:8px}
  .btn{background:linear-gradient(180deg,var(--accent),#2bd99a);color:#04221a;padding:10px 12px;border-radius:8px;border:none;font-weight:800;cursor:pointer}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 10px;border-radius:8px}

  /* center message */
  .center-msg{position:absolute;left:50%;top:14%;transform:translateX(-50%);z-index:9;background:rgba(0,0,0,0.4);padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,0.04)}
  .center-msg h2{margin:0 0 6px 0;color:var(--accent)}
  .center-msg p{margin:0;color:var(--muted)}

  /* touch controls for mobile */
  .touch-controls{position:absolute;left:12px;bottom:18px;z-index:11;display:flex;gap:8px}
  .touch-controls button{width:54px;height:54px;border-radius:10px;border:none;background:rgba(255,255,255,0.06);color:#fff;font-weight:800;font-size:18px}
  .touch-controls.right{right:12px;left:auto}

  /* modal */
  .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:999}
  .modal{width:92%;max-width:720px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.06)}
  .vault-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin-top:12px}
  .vault-card{padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
  .close{float:right;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 8px;border-radius:8px}

  /* footer small */
  .footer{position:absolute;left:50%;bottom:8px;transform:translateX(-50%);color:var(--muted);font-size:13px;z-index:10}
</style>
</head>
<body>
  <div id="container">
    <div id="gameWrap" role="application" aria-label="Symbiotic 3D game">
      <div class="hud">
        <div class="logo" title="Symbiotic">
          <img src="https://symbiotic.fi/logo.svg" alt="Symbiotic logo">
        </div>
        <div class="stats" aria-live="polite">
          <div>Score: <span id="score">0</span></div>
          <div class="muted">High: <span id="high">0</span></div>
        </div>
      </div>

      <div class="controls-right">
        <button id="startBtn" class="btn">Start</button>
        <button id="pauseBtn" class="ghost">Pause</button>
      </div>

      <div id="centerMsg" class="center-msg">
        <h2>Symbiotic 3D â€” Catch the Tokens</h2>
        <p>Use WASD or arrow keys to move. Collect green tokens. After every 5 tokens, learn about vaults.</p>
      </div>

      <!-- touch controls -->
      <div class="touch-controls" id="touchLeft" aria-hidden="true">
        <button id="leftBtn">â—€</button>
        <button id="upBtn">â–²</button>
        <button id="downBtn">â–¼</button>
        <button id="rightBtn">â–¶</button>
      </div>

      <div id="modalRoot" aria-hidden="true"></div>

      <div class="footer">Made with ðŸ’š for Symbiotic</div>
    </div>
  </div>

<script>
/*
Symbiotic 3D Collector â€” lightweight three.js game
- No build step. Uses three.js CDN.
- Controls: WASD / arrows. Touch buttons exist for mobile.
- Every 5 tokens: show vault modal.
- Score + highscore saved to localStorage.
*/

// ---- Config ----
const TOKEN_GOAL_SHOW = 5;
const START_TOKEN_COUNT = 8;
const TOKEN_RESPAWN_DELAY = 700; // ms
const ARENA_SIZE = 120; // world units (square half-extent)
const PLAYER_SPEED = 0.6;
const GRAVITY = 0.0;
const HIGH_KEY = 'symbiotic-3d-highscore-v1';

// vaults data shown in modal
const VAULTS = [
  { name: "L2 Security Vault", desc: "Secure L2 restaking w/ conservative strategies.", apy: "8.5%" },
  { name: "DEX Liquidity Vault", desc: "Fee-driven yields from LP positions.", apy: "12.2%" },
  { name: "Liquid Staking Vault", desc: "Optimizes across wstETH/stETH/rETH.", apy: "6.8%" },
  { name: "Yield Optimizer", desc: "Aggressive strategies, higher returns.", apy: "15.4%" }
];

// ---- State ----
let scene, camera, renderer, player, tokens = [], score = 0, highscore = 0, tokensCollected = 0;
let move = {forward:0,right:0};
let running = false;
let lastTime = 0;

// initialize three.js scene
function initThree(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x041812, 0.0025);

  const aspect = window.innerWidth / window.innerHeight;
  camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
  camera.position.set(0, 18, 32);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.getElementById('gameWrap').prepend(renderer.domElement);

  // lights
  const hemi = new THREE.HemisphereLight(0xffffee, 0x08151a, 0.55);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(10,20,10);
  scene.add(dir);

  // ground
  const groundMat = new THREE.MeshStandardMaterial({color:0x0a2b22, roughness:0.9, metalness:0.05});
  const groundGeo = new THREE.PlaneGeometry(ARENA_SIZE*2, ARENA_SIZE*2, 4,4);
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // grid helpers (subtle)
  const grid = new THREE.GridHelper(ARENA_SIZE*2, 40, 0x093226, 0x042018);
  grid.material.opacity = 0.18; grid.material.transparent = true;
  scene.add(grid);

  // skybox-like gradient (large dome)
  const skyGeo = new THREE.SphereGeometry(300, 32, 32);
  const skyMat = new THREE.MeshBasicMaterial({ color: 0x04221a, side: THREE.BackSide });
  const sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);

  // player: glowing orb
  const pMat = new THREE.MeshStandardMaterial({color:0x9cffcf, emissive:0x2bd99a, metalness:0.3, roughness:0.2});
  const pGeo = new THREE.SphereGeometry(1.2, 24, 24);
  player = new THREE.Mesh(pGeo, pMat);
  player.position.set(0,1.2,0);
  scene.add(player);

  // subtle particle glow (sprite)
  const spriteMat = new THREE.SpriteMaterial({ color: 0x9cffcf, opacity:0.08 });
  const glow = new THREE.Sprite(spriteMat);
  glow.scale.set(10,10,1);
  player.add(glow);

  // camera target pivot
  camera.lookAt(player.position);

  // populate tokens
  for(let i=0;i<START_TOKEN_COUNT;i++) spawnToken();

  // load highscore
  highscore = parseInt(localStorage.getItem(HIGH_KEY) || '0', 10);
  document.getElementById('high').textContent = highscore;

  // events
  window.addEventListener('resize', onResize);
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);

  // touch controls
  attachTouchControls();

  // start render loop (idle)
  animate(0);
}

function onResize(){
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function spawnToken(){
  const tokenGeom = new THREE.SphereGeometry(0.6, 18, 18);
  const tokenMat = new THREE.MeshStandardMaterial({ color:0x2ee7a8, emissive:0x28d99a, metalness:0.2, roughness:0.2 });
  const t = new THREE.Mesh(tokenGeom, tokenMat);

  // position within arena (avoid center overlap)
  let x = (Math.random()*2-1) * (ARENA_SIZE - 6);
  let z = (Math.random()*2-1) * (ARENA_SIZE - 6);
  t.position.set(x, 0.6, z);

  scene.add(t);
  tokens.push(t);
}

function clearTokens(){
  tokens.forEach(t=> scene.remove(t));
  tokens = [];
}

// input handlers
function onKeyDown(e){
  if(e.key === 'w' || e.key === 'ArrowUp') move.forward = 1;
  if(e.key === 's' || e.key === 'ArrowDown') move.forward = -1;
  if(e.key === 'a' || e.key === 'ArrowLeft') move.right = -1;
  if(e.key === 'd' || e.key === 'ArrowRight') move.right = 1;
  if(e.key === 'p') togglePause();
}

function onKeyUp(e){
  if((e.key === 'w' || e.key === 'ArrowUp') && move.forward === 1) move.forward = 0;
  if((e.key === 's' || e.key === 'ArrowDown') && move.forward === -1) move.forward = 0;
  if((e.key === 'a' || e.key === 'ArrowLeft') && move.right === -1) move.right = 0;
  if((e.key === 'd' || e.key === 'ArrowRight') && move.right === 1) move.right = 0;
}

// attach touch buttons
function attachTouchControls(){
  ['leftBtn','upBtn','downBtn','rightBtn'].forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener('touchstart', (ev)=> { ev.preventDefault(); handleTouchDown(id); }, {passive:false});
    el.addEventListener('touchend', (ev)=> { ev.preventDefault(); handleTouchUp(id); }, {passive:false});
  });
}
function handleTouchDown(id){
  if(id === 'leftBtn') move.right = -1;
  if(id === 'rightBtn') move.right = 1;
  if(id === 'upBtn') move.forward = 1;
  if(id === 'downBtn') move.forward = -1;
}
function handleTouchUp(id){
  if(id === 'leftBtn' && move.right === -1) move.right = 0;
  if(id === 'rightBtn' && move.right === 1) move.right = 0;
  if(id === 'upBtn' && move.forward === 1) move.forward = 0;
  if(id === 'downBtn' && move.forward === -1) move.forward = 0;
}

// camera follow
function updateCamera(){
  // third-person follow
  const desiredPos = new THREE.Vector3(player.position.x - 6*move.right, player.position.y + 8, player.position.z + 14 - move.forward*6);
  camera.position.lerp(desiredPos, 0.08);
  camera.lookAt(player.position);
}

// game loop
function animate(time){
  requestAnimationFrame(animate);
  const dt = Math.min(0.06, (time - lastTime) / 1000);
  lastTime = time;

  if(running){
    // move player based on move vector
    const forwardSpeed = move.forward * PLAYER_SPEED;
    const rightSpeed = move.right * PLAYER_SPEED;

    // compute forward vector relative to camera orientation on XZ plane
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0; camDir.normalize();

    const rightDir = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), camDir).normalize();

    player.position.addScaledVector(camDir, forwardSpeed * dt * 60);
    player.position.addScaledVector(rightDir, rightSpeed * dt * 60);

    // clamp to arena
    player.position.x = THREE.MathUtils.clamp(player.position.x, -ARENA_SIZE, ARENA_SIZE);
    player.position.z = THREE.MathUtils.clamp(player.position.z, -ARENA_SIZE, ARENA_SIZE);

    // rotate player to movement direction if moving
    const vx = forwardSpeed * camDir.x + rightSpeed * rightDir.x;
    const vz = forwardSpeed * camDir.z + rightSpeed * rightDir.z;
    if(Math.abs(vx) + Math.abs(vz) > 0.001){
      const angle = Math.atan2(vx, vz); // note swapping to align visual
      player.rotation.y = THREE.MathUtils.lerpAngle(player.rotation.y, angle, 0.12);
    }

    // simple bob
    player.position.y = 1.2 + Math.sin(time*0.002 + player.position.x*0.1)*0.06;

    // check collisions with tokens
    for(let i = tokens.length - 1; i >= 0; i--){
      const t = tokens[i];
      const dist = player.position.distanceTo(t.position);
      if(dist < 1.6){
        // collected
        scene.remove(t);
        tokens.splice(i,1);
        onTokenCollected();
      } else {
        // rotate tokens slowly
        t.rotation.y += 0.02;
      }
    }

    // spawn new tokens if too few
    if(tokens.length < 6){
      // spawn after small delay to avoid immediate stacking
      setTimeout(spawnToken, TOKEN_RESPAWN_DELAY);
    }

    updateCamera();
  }

  renderer.render(scene, camera);
}

// when token collected
function onTokenCollected(){
  score += 10;
  tokensCollected += 1;
  document.getElementById('score').textContent = score;
  // update high score if needed
  if(score > highscore){
    highscore = score;
    document.getElementById('high').textContent = highscore;
    localStorage.setItem(HIGH_KEY, highscore.toString());
  }

  // every TOKEN_GOAL_SHOW tokens, show vault modal
  if(tokensCollected % TOKEN_GOAL_SHOW === 0){
    running = false;
    showVaultModal();
  }
}

// show vault modal (teaching moment)
function showVaultModal(){
  const modalRoot = document.getElementById('modalRoot');
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay';
  overlay.innerHTML = `
    <div class="modal" role="dialog" aria-modal="true">
      <button class="close">Close</button>
      <h3>Featured Symbiotic Vaults</h3>
      <p class="muted">Great! You collected ${tokensCollected} tokens. Here are some vaults in the Symbiotic ecosystem.</p>
      <div class="vault-grid">
        ${VAULTS.map(v => `<div class="vault-card"><strong>${v.name}</strong><div style="color:var(--muted);margin-top:6px">${v.desc}</div><div style="margin-top:8px;color:var(--accent);font-weight:800">${v.apy}</div></div>`).join('')}
      </div>
    </div>
  `;
  modalRoot.appendChild(overlay);
  overlay.querySelector('.close').addEventListener('click', ()=> {
    modalRoot.removeChild(overlay);
    running = true; // resume
  });
}

// start / pause handlers
document.getElementById('startBtn').addEventListener('click', ()=>{
  if(!scene) initThree();
  running = true;
  document.getElementById('centerMsg').style.display = 'none';
  document.getElementById('startBtn').disabled = true;
});
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  togglePause();
});

function togglePause(){
  running = !running;
  document.getElementById('pauseBtn').textContent = running ? 'Pause' : 'Resume';
  if(!running){
    document.getElementById('centerMsg').style.display = 'block';
    document.getElementById('centerMsg').querySelector('h2').textContent = 'Paused';
  } else {
    document.getElementById('centerMsg').style.display = 'none';
  }
}

// initial UI update
document.getElementById('score').textContent = score;
document.getElementById('high').textContent = highscore;

// helper: animate spawn a ring or bounce (optional) - omitted to keep code small

// initialize scene on first interaction or load small placeholder
window.addEventListener('load', ()=> {
  // Render a placeholder canvas right away by initThree (so users see 3D)
  initThree();
  // Show center message until Start pressed
});

// expose simple window cleanup on unload
window.addEventListener('beforeunload', ()=> {
  if(renderer) renderer.dispose && renderer.dispose();
});

</script>
</body>
</html>
